import t from"../../pfelement/dist/pfelement.min.js";function e(t,e,a){return a<0&&(a+=1),a>1&&(a-=1),6*a<1?t+6*(e-t)*a:2*a<1?e:3*a<2?t+(e-t)*(2/3-a)*6:t}
/*!
 * PatternFly Elements: PfeAvatar 1.0.0-prerelease.45
 * @license
 * Copyright 2020 Red Hat, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
*/
class a extends t{static get version(){return"1.0.0-prerelease.45"}get html(){return"<style>:host{--pfe-avatar--width:128px;display:block;position:relative;width:var(--pfe-avatar--width);height:var(--pfe-avatar--width)}:host canvas{width:100%;height:100%;image-rendering:optimizeSpeed;image-rendering:-moz-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:-o-crisp-edges;image-rendering:-o-pixelated;image-rendering:pixelated;-ms-interpolation-mode:nearest-neighbor}:host([pfe-shape=rounded]) canvas,:host([pfe-shape=rounded]) img{border-radius:calc(var(--pfe-avatar--width)/ 8 + 1px)}:host([pfe-shape=circle]) canvas,:host([pfe-shape=circle]) img{border-radius:50%}:host([pfe-src]) canvas{display:none}:host([pfe-src]) img{display:block;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}:host(:not([pfe-src])) img{display:none}:host([hidden]){display:none}\n/*# sourceMappingURL=pfe-avatar.min.css.map */\n</style><canvas></canvas>\n<img>"}static get tag(){return"pfe-avatar"}get templateUrl(){return"pfe-avatar.html"}get styleUrl(){return"pfe-avatar.scss"}static get observedAttributes(){return["pfe-name","pfe-pattern","pfe-src","pfe-shape"]}static get events(){return{connected:`${this.tag}:connected`}}static get patterns(){return{triangles:"triangles",squares:"squares"}}static get defaultSize(){return 128}static get defaultColors(){return"#67accf #448087 #709c6b #a35252 #826cbb"}get name(){return this.getAttribute("pfe-name")}set name(t){return this.setAttribute("pfe-name",t)}get src(){return this.getAttribute("pfe-src")}set src(t){return this.setAttribute("pfe-src",t)}get pattern(){return this.getAttribute("pfe-pattern")||a.patterns.squares}set pattern(t){if(a.patterns[t])return this.setAttribute("pfe-pattern",t);this.log(`invalid pattern "${t}", valid patterns are: ${Object.values(a.patterns)}`)}constructor(){super(a)}connectedCallback(){super.connectedCallback(),this._initCanvas(),this.emitEvent(a.events.connected,{bubbles:!1})}attributeChangedCallback(t,e,r){super.attributeChangedCallback(...arguments),this.connected?this.update():this.addEventListener(a.events.connected,()=>this.update())}_initCanvas(){this._canvas=this.shadowRoot.querySelector("canvas");const t=this.var("--pfe-avatar--width").replace(/px$/,"")||a.defaultSize;this._canvas.width=t,this._canvas.height=t,this._squareSize=this._canvas.width/8,this._triangleSize=this._canvas.width/4,this._ctx=this._canvas.getContext("2d")}static _registerColors(){return this.colors=[],(this.var("--pfe-avatar--colors")||this.defaultColors).split(/\s+/).forEach(t=>{let e;switch(t.length){case 4:if(e=/^#([A-f0-9])([A-f0-9])([A-f0-9])$/.exec(t)){e.shift();const t=e.map(t=>parseInt(t+t,16));this._registerColor(t)}else this.log(`[pfe-avatar] invalid color ${t}`);break;case 7:if(e=/^#([A-f0-9]{2})([A-f0-9]{2})([A-f0-9]{2})$/.exec(t)){e.shift();const t=e.map(t=>parseInt(t,16));this._registerColor(t)}else this.log(`[pfe-avatar] invalid color ${t}`)}}),this.colors}static _registerColor(t){a.colors.push({color1:`rgb(${t.join(",")})`,color2:`rgb(${this._adjustColor(t).join(",")})`})}static _adjustColor(t){const a=function(t,e,a){let r,s,i;const n=Math.max(0,Math.min(255,t))/255,h=Math.max(0,Math.min(255,e))/255,o=Math.max(0,Math.min(255,a))/255,c=Math.min(Math.min(n,h),o),l=Math.max(Math.max(n,h),o),d=l-c;if(i=(l+c)/2,0===d)r=0,s=0;else{s=i<.5?d/(l+c):d/(2-l-c);const t=((l-n)/6+d/2)/d,e=((l-h)/6+d/2)/d,a=((l-o)/6+d/2)/d;n==l?r=a-e:h==l?r=1/3+t-a:o==l&&(r=2/3+e-t),r<0?r+=1:r>1&&(r-=1)}return[r,s,i]}(...t);return a[2]+=a[2]>.1?-.1:.1,function(t,a,r){let s,i,n;const h=Math.max(0,Math.min(1,t)),o=Math.max(0,Math.min(1,a)),c=Math.max(0,Math.min(1,r));if(0==o)s=255*c,i=255*c,n=255*c;else{let t,a;t=2*c-(a=c<.5?c*(1+o):c+o-o*c),s=Math.floor(255*e(t,a,h+1/3)),i=Math.floor(255*e(t,a,h)),n=Math.floor(255*e(t,a,h-1/3))}return[s,i,n]}(...a)}update(){if(this.hasAttribute("pfe-src"))this.shadowRoot.querySelector("img").src=this.src;else{const t=function(t){let e=5381,a=t.length;for(;a;)e=33*e^t.charCodeAt(--a);return e>>>0}(this.name).toString(2),e=t.split("").map(t=>Number(t));this._colorIndex=Math.floor(a.colors.length*parseInt(t,2)/Math.pow(2,32)),this.color1=a.colors[this._colorIndex].color1,this.color2=a.colors[this._colorIndex].color2,this._clear(),this._drawBackground(),this.pattern===a.patterns.squares?this._drawSquarePattern(e):this.pattern===a.patterns.triangles&&this._drawTrianglePattern(e)}}_clear(){this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height)}_drawBackground(){this._ctx.fillStyle=this.color1,this._ctx.fillRect(0,0,this._canvas.width,this._canvas.height)}_drawSquarePattern(t){if(this._ctx.fillStyle=this.color2,this._ctx){let e=t.length;for(;e--;)t[e]&&this._drawMirroredSquare(e%4,Math.floor(e/4))}}_drawMirroredSquare(t,e){this._ctx&&(this._drawSquare(t,e),this._drawSquare(7-t,e))}_drawSquare(t,e){this._ctx.fillRect(this._squareSize*t,this._squareSize*e,this._squareSize,this._squareSize)}_drawTrianglePattern(t){if(this._ctx.fillStyle=this.color2,this._ctx){let e=t.length;for(;e--;)if(t[e]){const t=Math.floor(e/2)%2,a=Math.floor(e/4),r=[t,a],s=[t,a],i=[t,a];switch(e%4){case 0:s[1]++,i[0]++,i[1]++;break;case 1:s[0]++,i[0]++,i[1]++;break;case 2:s[0]++,i[1]++;break;case 3:r[0]++,s[0]++,s[1]++,i[1]++}this._drawMirroredTriangle(r,s,i)}}}_drawMirroredTriangle(t,e,a){this._ctx&&(this._drawTriangle(t,e,a),this._drawTriangle([4-t[0],t[1]],[4-e[0],e[1]],[4-a[0],a[1]]))}_drawTriangle(t,e,a){this._ctx.beginPath(),this._ctx.moveTo(...t.map(t=>t*this._triangleSize)),this._ctx.lineTo(...e.map(t=>t*this._triangleSize)),this._ctx.lineTo(...a.map(t=>t*this._triangleSize)),this._ctx.closePath(),this._ctx.fill(),this._ctx.fill()}_drawGradient(){const t=this._ctx.createLinearGradient(0,this._canvas.height,this._canvas.width,0),e=this.color2;let a=e,r=e;/^#[A-f0-9]{3}$/.test(e)?(a+="c",r+="0"):/^#[A-f0-9]{6}$/.test(e)&&(a+="cc",r+="00"),t.addColorStop(0,a),t.addColorStop(1,r),t.addColorStop(1,a),this._ctx.fillStyle=t,this._ctx.fillRect(0,0,this._canvas.width,this._canvas.height)}}a._registerColors(),t.create(a);export default a;
//# sourceMappingURL=pfe-avatar.min.js.map

{
  "title": "Creating your first cloud-agnostic serverless application with Java",
  "link": "https://blog.kie.org/2022/09/creating-your-first-cloud-agnostic-serverless-application-with-java.html",
  "author": [
    {
      "name": "Helber Belmiro",
      "avatar": null
    }
  ],
  "date": "2022-09-22T10:35:00.000Z",
  "feed_title": "KIE Community",
  "content": "If you are new to Serverless Workflow or serverless in general, creating a simple application for a serverless infrastructure is a good place to start.  In this article, you will run through the steps to create your first serverless Java application that runs on any cloud.   WHAT IS SERVERLESS?  Contrary to what the name says, there are still servers in serverless, but you don’t need to worry about managing them. You just need to deploy your containers and the serverless infrastructure is responsible for providing resources to your application scale up or down.  The best part is that it automatically scales up when there is a high demand or scales to zero when there is no demand. This will reduce the amount of money you spend with the cloud.   WHAT WILL YOU CREATE?  You will use Quarkus to create a simple Java application that returns a greeting message to an HTTP request and deploy it to Knative.   WHY KNATIVE?  In the beginning, serverless applications used to consist of small pieces of code that were run by a cloud vendor, like AWS Lambda. In this first phase, the applications had some limitations and were closely coupled to the vendor libraries.  Knative enables developers to run serverless applications on a Kubernetes cluster. This gives you the flexibility to run your applications on any cloud, on-premises, or even mix all of them.   WHY QUARKUS?  Because serverless applications need to start fast.  Since the biggest advantage of serverless is scale up and down (even zero) according to demand, serverless applications need to start fast when scaling up, otherwise, requests would be denied.  One of the greatest characteristics of Quarkus applications is their super fast start-up.  Also, Quarkus is , which means that it’s easy to deploy Quarkus applications to Kubernetes without having to understand the intricacies of the underlying Kubernetes framework.   REQUIREMENTS   * A local Knative installation. See .    * This article uses minikube as the local Kubernetes cluster.  * kn CLI installed. See .  * JDK 11+ installed with JAVA_HOME configured appropriately.  * Apache Maven 3.8.1+.  * GraalVM (optional to deploy a native image).   CREATE A QUARKUS APPLICATION  > NOTE: If you don’t want to create the application, you can just clone it > from  and skip to    mvn io.quarkus.platform:quarkus-maven-plugin:2.11.2.Final:create \\     -DprojectGroupId=org.acme \\     -DprojectArtifactId=knative-serving-quarkus-demo  cd knative-serving-quarkus-demo    RUN YOUR APPLICATION LOCALLY  To verify that you created the project correctly, run the project locally by running the following command:   mvn quarkus:dev   After downloading the dependencies and building the project, you should see an output similar to:   __  ____  __  _____   ___  __ ____  ______   --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/   -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\    --\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/    2022-08-15 16:50:25,135 INFO  [io.quarkus] (Quarkus Main Thread) knative-serving-quarkus-demo 1.0.0-SNAPSHOT on JVM (powered by Quarkus 2.11.2.Final) started in 1.339s. Listening on: http://localhost:8080  2022-08-15 16:50:25,150 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated. 2022-08-15 16:50:25,150 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy-reactive, smallrye-context-propagation, vertx]   On a different terminal window or in the browser, you can access the application by sending a request to the  endpoint:   curl -X 'GET' 'http://localhost:8080/hello' -H 'accept: text/plain'   If you see the following output, then you have successfully created your application:   Hello from RESTEasy Reactive   Hit Ctrl + C to stop the application.   PREPARE YOUR APPLICATION FOR DEPLOYMENT TO KNATIVE   ADD THE REQUIRED DEPENDENCIES  Add the following dependencies to the pom.xml file:   <dependency>     <groupId>io.quarkus</groupId>     <artifactId>quarkus-kubernetes</artifactId> </dependency>  <dependency>     <groupId>io.quarkus</groupId>     <artifactId>quarkus-container-image-jib</artifactId> </dependency>    CONFIGURE THE APPLICATION FOR DEPLOYMENT TO KNATIVE  Add the following configuration to the src/main/resources/application.properties file:   quarkus.kubernetes.deployment-target=knative quarkus.container-image.group=dev.local/hbelmiro   > NOTE: In the quarkus.container-image.group property, replace hbelmiro with > your container registry username.   DEPLOY YOUR APPLICATION TO KNATIVE   START THE MINIKUBE TUNNEL  > NOTE: This step is only necessary if you are using minikube as the local > Kubernetes cluster.  On a different terminal window, run the following command to start the minikube tunnel:   minikube tunnel --profile knative   You should see an output similar to the following:   Status:\t \tmachine: knative \tpid: 223762 \troute: 10.96.0.0/12 -> 192.168.49.2 \tminikube: Running \tservices: [kourier]     errors:  \t\tminikube: no errors \t\trouter: no errors \t\tloadbalancer emulator: no errors   Leave the terminal window open and running the above command.   CONFIGURE THE CONTAINER CLI TO USE THE CONTAINER ENGINE INSIDE MINIKUBE   eval $(minikube -p knative docker-env)    DEPLOY THE APPLICATION  Run the following command to deploy the application to Knative:   mvn clean package -Dquarkus.kubernetes.deploy=true   You should see an output similar to the following:   [INFO] [io.quarkus.kubernetes.deployment.KubernetesDeployer] Deploying to knative server: https://192.168.49.2:8443/ in namespace: default. [INFO] [io.quarkus.kubernetes.deployment.KubernetesDeployer] Applied: Service knative-serving-quarkus-demo. [INFO] [io.quarkus.deployment.QuarkusAugmentor] Quarkus augmentation completed in 8952ms [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------    CHECK THE KNATIVE DEPLOYED SERVICES  Run the following command to check the Knative deployed services:   kn service list   You should see your application listed on the deployed services like the following:   NAME                           URL                                                                   LATEST                               AGE   CONDITIONS   READY   REASON knative-serving-quarkus-demo   http://knative-serving-quarkus-demo.default.10.106.207.219.sslip.io   knative-serving-quarkus-demo-00001   23s   3 OK / 3     True   > IMPORTANT: In the above output, check the READY status of the application. If > the status is not True, then you need to wait for the application to be ready, > or there is a problem with the deployment.   SEND A REQUEST TO THE DEPLOYED APPLICATION  Use the URL returned by the above command to send a request to the deployed application.   curl -X 'GET' 'http://knative-serving-quarkus-demo.default.10.106.207.219.sslip.io/hello' -H 'accept: text/plain'   You should see the following output:   Hello from RESTEasy Reactive    GOING NATIVE  You can create a native image of your application to make it start even faster. To do that, deploy your application by using the following command:   mvn clean package -Pnative -Dquarkus.native.native-image-xmx=4096m -Dquarkus.native.remote-container-build=true -Dquarkus.kubernetes.deploy=true   > IMPORTANT: -Dquarkus.native.native-image-xmx=4096m is the amount of memory > Quarkus can use to generate the native image. You should adjust it or > completely remove it depending on your local machine’s specifications.   NOW YOU ARE READY TO RUN SERVERLESS APPLICATIONS USING JAVA  Easy, isn’t it? Quarkus and Knative give you the freedom to run serverless applications using Java on-premises or in the cloud, no matter the vendor. You can even mix more than one cloud vendor with your on-premises infrastructure. This flexibility brings you agility and reduces your costs with infrastructure.   NEXT STEP  If you want to go further on serverless with more exciting stuff, check out   The post appeared first on ."
}
{
  "title": "Infinispan 14.0.0.Final",
  "link": "https://infinispan.org/blog/2022/09/29/infinispan-14",
  "author": [
    {
      "name": "Tristan Tarrant",
      "avatar": "https://www.gravatar.com/avatar/b91126c20f0d38f1ce1750d5a2b2bcb8?s=50"
    }
  ],
  "date": "2022-09-29T12:00:00.000Z",
  "feed_title": "Infinispan",
  "content": "Flying saucers are probably the most common type of UFO. They are sleek and shiny and, most importantly, they come in peace bringing lots of goodies from outer space! Just like Infinispan 14! Oh, and the fact that it’s also the is no sheer coincidence.     JDK REQUIREMENTS  You will need at least JDK 11 in order to use Infinispan 14. Infinispan also supports JDK 17 LTS and the recently released JDK 19.   JAKARTA EE  We now ship variants of most of our modules: just append -jakarta to the artifact name:  <dependency>    <groupId>org.infinispan</groupId>    <artifactId>infinispan-core-jakarta</artifactId>    <version>14.0.0.Final</version> </dependency>   CORE   * Cluster Listener using includeCurrentState` will have better memory and    performance performance. Every key no longer requires calculating its segment    while iterating and memory is freed much earlier and is closed as each    segment completes transfer   * State Transfer reduces how long memory is required to be held therefore    reducing required memory overheads when configuring your server.   * State transfer metrics are exposed through JMX. Expose the number of segments    during transfer.   * Size method when invoked on a cache has been optimized in various cases to be    an O(1) operation instead of O(N). Involves if expiration and if stores are    configured, please check for more information.   * Reduced some cases of blocking threads being over utilized, therefore    reducing how large the blocking thread pool would need to grow.   * Dynamic RBAC: a dynamic, clustered role mapper that can be modified at    runtime to grant/deny access to specific principals.   QUERY   * Native Infinispan indexing annotations which finally replace the legacy    Hibernate Query annotations we’ve used in past versions (see )   * Index startup mode to determine what happens to indexes on cache start (see )   * Dynamic index schema updates allow you to evolve your schema at runtime with    near-zero impact to your queries (see )   * Support Protobuf’s oneof   * We improved the hybrid query system   * Support normalizers with the HotRod client   PERSISTENCE   * SoftIndexFileStore (default file store) segmentation performance has been    improved significantly. This also reduces the number of Index segments    required which reduces the number of open files and threads required on the    server.   * JDBCStringBasedStore no longer requires configuring the database min and max    version as this is dynamically configured when checking the JDBC connection.   * JPAStore has been removed. It had been deprecated for quite a while, but the    move to support Hibernate 6 prompted its removal as JPAStore only worked with    Hibernate 5.   HOT ROD CLIENT   * A new Hot Rod client with a completely redesigned API.   * Sync (blocking), Async (non-blocking) and sub-APIs that fit with your    programming model of choice.        try (SyncContainer infinispan = Infinispan.create(\"hotrod://localhost\")) {        // Sync        SyncCache<String, String> mycache = infinispan.sync().caches().get(\"mycache\");        mycache.set(\"key\", \"value\");        String value = mycache.get(\"key\");        // set with options        mycache.set(\"key\", \"anothervalue\", writeOptions().lifespan(Duration.ofHours(1)).timeout(Duration.ofMillis(500)).build());            // Async        infinispan.async().caches()        .get(\"mycache\").thenApply(c ->            c.set(\"key\", \"value\").thenApply(ignore ->                c.get(\"key\").thenApply(value ->                    c.set(\"key\", \"anothervalue\",                    writeOptions().lifespan(Duration.ofHours(1)).timeout(Duration.ofMillis(500)).build()))                ));            // Mutiny        infinispan.mutiny().caches()        .get(\"mycache\").map(c ->            c.query(\"age > :age\").param(\"age\", 80).skip(5).limit(10).find())                .subscribe().with(System.out::println);    }   SERVER   * RESP endpoint: a Redis-compatible endpoint connector (implementing the RESP 3    protocol) with support for a subset of commands: set, get, del, mget, mset,    incr, decr, publish, subscribe, auth, ping. The connector integrates with our    security and protocol auto-detections, so that it is easily usable from our    single-port endpoint. The implemented commands should be enough for typical    caching usage. If you would like to see more, reach out via our community.   * If you need to use , it’s now possible to use   * Masked and external credentials, to avoid the use of secrets in your    configuration files   * Custom security providers, such as BouncyCastle, can now be used. Just drop    your provider implementation in the server/lib and configure:        <ssl>        <keystore path=\"server.bcfks\" password=\"secret\" alias=\"server\" provider=\"BC\" type=\"BCFKS\"/>    </ssl>   * Improved TLS engine configuration, allowing fine-grained ciphersuites    selection for both TLSv1.3 and TLSv1.2:        <engine enabled-protocols=\"TLSv1.3 TLSv1.2\" enabled-ciphersuites=\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\" enabled-ciphersuites-tls13=\"TLS_AES_256_GCM_SHA384\"/>   * Endpoint worker threads configuration has been removed. With the rewrite in    Infinispan 13 to utilize non blocking threads, this configuration was unused    and deprecated.   * integration with our security realms for authentication and authorization.   * Experimental support   * REST endpoints expose distribution information for caches and clusters. For    more information, see and .   CONSOLE   * Cache creation wizard. See our recent about it   CLI   * List cache entries, including metadata, using different formats (table, JSON,    CSV)   * Configuration converter   * Schema command to upload, delete, modify protobuf schema   * Index command to manage indexes   * Client certificate authentication   IMAGE   * Now based upon   * Images provided for both amd64 and arm64 architectures   * SERVER_LIBS environment variable added to allow dependencies to be downloaded    prior to server startup   * The config-generator has been removed. Its functionality can be replaced by    using configuration overlays   OPERATOR   * Multi-Operand support, which means a single operator can managed different    versions of Infinispan   * FIPS support   * Custom user configuration refactored to allow greater control of Infinispan    configuration   * Image based upon   * Bundle provided for both amd64 and arm64 architectures   * Admin service is now headless   HIBERNATE ORM SECOND-LEVEL CACHE  Hibernate caching implementation supporting Hibernate 6. Note that Hibernate 5 caching support is no longer provided due to Jakarta EE migration.   OBSERVABILITY   * Integration with OpenTelemetry tracing (see )   * Client / server request tracing correlations on both Hot Rod and REST APIs    (see )   * Integration with Micrometer to produce Prometheus and OpenMetrics metrics   OTHER  Infinispan Quarkus server now supports the same command line arguments as the normal JVM Infinispan server. In addition the Infinispan Quarkus native binary can be used in an existing unzipped Infinispan Server zip file for ease of use.   DOCUMENTATION  Many improvements, updates and fixes.   RELEASE NOTES  You can look at the to see what has changed since our latest CR.  Get them from our ."
}
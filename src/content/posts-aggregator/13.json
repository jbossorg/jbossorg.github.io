{
  "title": "First Steps with Dapr",
  "link": "http://www.ofbizian.com/2022/08/first-steps-with-dapr.html",
  "author": [
    {
      "name": "Unknown",
      "avatar": null
    }
  ],
  "date": "2022-08-13T10:33:00.007Z",
  "feed_title": "OFBizian",
  "feed_avatar": "https://www.gravatar.com/avatar/279246bd111a7c211134179eddb94afa?s=50",
  "content": "I recently to and work on the Dapr project. I about Dapr when it was initially announced by Microsoft, but hadn’t looked into it since it CNCF. Two years later, during my onboarding into the new role, I spent some time looking into it and here are the steps I took in the journey and my impressions so far.   WHAT IS DAPR?  TL;DR: Dapr is a distributed systems toolkit in a box. It addresses the peripheral integration concerns of applications and lets developers focus on the business logic. If you are familiar with Apache Camel, Spring Framework in the Java world, or other distributed systems frameworks, you will find a lot of similarities with Dapr. Here are a few parallels with other frameworks:    * Similar to Camel, Dapr has connectors (called ) that let you connect to    various external systems.  * Similar to HashiCorp Consul, Dapr offers which can be backed by Consul.  * Similar to Spring Integration, Spring Cloud, (remember Netflix Hystrix?) and    many other frameworks, Dapr has error handling capabilities with retries,    timeouts, circuit breakers which are called .  * Similar to Spring Data KeyValue, Dapr offers Key/Value-based state    abstractions.  * Similar to Kafka, Dapr offers pub/sub-based service interactions.  * Similar to ActiveMQ clients, Dapr offers , but these are not specific to a    messaging technology, which means they can be used even with things such as    AWS SQS or Redis for example.  * Similar to Spring Cloud Config, Dapr offers configuration and secret    management  * Similar to Zookeeper or Redis clients, Dapr offers  * Similar to a Service Mesh, Dapr offers mTLS and between your application and    the sidecar.  * Similar to Envoy, Dapr offers enhanced through automatic metrics, tracing and    log collection.  The primary difference between all of these frameworks and Dapr is that the latter offers its capabilities not as a library within your application, but as a sidecar running next to your application. These capabilities are exposed behind well-defined HTTP and gRPC APIs (very creatively called ) where the implementations (called ) can be swapped w/o affecting your application code.       High-level Dapr architecture    You could say, Dapr is a collection of stable APIs exposed through a sidecar and swappable implementations running somewhere else. It is the cloudnative incarnation of integration technologies that makes integration capabilities previously available only in a few languages, available to everybody, and portable everywhere: Kubernetes, on-premise, or literally (I mean the edge).      GETTING STARTED  The project is surprisingly easy to get up and running regardless of your developer background and language of choice. I was able to follow the getting started guides and run various quickstarts in no time on my MacOS. Here are roughly the steps I followed.   INSTALL DAPR CLI    Dapr CLI is the main tool for performing Dapr-related tasks such as running an application with Dapr, seeing the logs, running Dapr dashboard, or deploying all to Kubernetes.  brew install dapr/tap/dapr-cli  With the CLI installed, we have a few different options for installing and running Dapr. I’ll start from the least demanding and flexible option and progress from there.   OPTION 1: INSTALL DAPR WITHOUT DOCKER  This is the lightest but not the most useful way to run Dapr.  dapr init --slim  In this only daprd and placement binaries are installed on the machine which is sufficient for running Dapr sidecars locally.   Run a Dapr sidecar  The following command will start a Dapr sidecar called no-app listening on HTTP port 3500 and a random gRPC port.   dapr run --app-id no-app --dapr-http-port 3500  Congratulations, you have your first Dapr sidecar running. You can see the sidecar instance through this command:  dapr list  or query its health status:  curl -i http://localhost:3500/v1.0/healthz  Dapr sidecars are supposed to run next to an application and not on their own. Let’s stop this instance and run it with an application.  dapr stop --app-id no-app  Run a simple app with a Dapr sidecar  For this demonstration we will use a simple NodeJS :  git clone  cd samples/hello-dapr-slim  npm install  This is a Hello World the Dapr way and here is the gist of it:  app.post('/neworder', bodyParser.json(), (req, res) => {  const data = req.body.data;  const orderId = data.orderId;  res.status(200).send(\"Got a new order! Order ID: \" + orderId); });   The application has one /neworder endpoint listening on port 3000. We can run this application and the sidecar with the following command:  dapr run --app-id nodeapp --app-port 3000 --dapr-http-port 3500 node app.js  The command starts the NodeJS application on port 3000 and Dapr HTTP endpoint on 3500. Once you see in the logs that the app has started successfully, we can poke it. But rather than hitting the /neworder endpoint directly on port 3000, we will instead interact with the application through the sidecar. We do that using Dapr CLI like this:  dapr invoke --verb POST --app-id nodeapp --method neworder --data '{\"data\": { \"orderId\": \"41\" } }'  And see the response from the app. If you noticed, the CLI only needs the app-id (instead of host and port) to locate where the service is running. The CLI is just a handy way to interact with your service. It that seems like too much magic, we can use bare-bones curl command too:  curl -XPOST -d @sample.json -H \"Content-Type:application/json\" http://localhost:3500/v1.0/invoke/nodeapp/method/neworder  This command uses the service Dapr’s invocation API to synchronously interact with the application. Here is a visual representation of what just happened:      Invoking an endpoint through Dapr sidecar    Now, with Dapr on the request path, we get the Daprized service invocation benefits such as resiliency policies such as retries, timeouts, circuit breakers, concurrency control; observability enhancements such as: metrics, tracing, logs; security enhancements such as mTLS, , etc. At this point, you can try out metadata, metrics endpoints, play with the options, or see your single microservice in Dapr dashboard.  dapr dashboard  The slim mode we are running on is good for the Hello World scenario, but not the best setup for local development purposes as it lacks state store, pub/sub, metric server, etc. Let’s stop the nodeapp using the command from earlier (or CTL +C), and remove the slim Dapr binary:  dapr uninstall  One thing to keep in mind is that this command will not remove the default configuration and component specification files usually located in: ~/.dapr folder. We didn’t create any files in the steps so far, but if you follow other tutorials and change those files, they will remain and get applied with every dapr run command in the future (unless overridden). This caused me some confusion, keep it in mind.   OPTION 2: INSTALL DAPR WITH DOCKER    This is the preferred way for running for development purposes but it requires Docker. Let’s set it up:  dapr init  The command will download and run 3 containers    * Dapr placement container used with actors(I wish this was an optional    feature)  * Zipkin for collecting tracing information from our sidecars  * And a single node Redis container used for state store, pub/sub,    distributed-lock implementations.  You can verify when these containers are running and you are ready to go. docker ps   RUN THE QUICKSTARTS  My next step from here was to try out the that demonstrate the building blocks for service invocation, pub/sub, state store, bindings, etc. The awesome thing about these quickstarts is that they demonstrate the same example in multiple ways:  * With Dapr SDK and w/o any dependency to Dapr SDK i.e. using HTTP only.  * In multiple languages: Java, Javascript, .Net, Go, Python, etc.  You can mix and match different languages and interaction methods (SDK or native) for the same example which demonstrates Dapr’s polyglot nature.  Option 3: Install Dapr on Kubernetes  If you have come this far, you should have a good high-level understanding of what Dapr can do for you. The next step would be to deploy where most of the Dapr functionalities are available and closest to a production deployment. For this purpose, I used minikube locally with default settings and no custom tuning. dapr init --kubernetes --wait  If successful, this command will start the following pods in dapr-system namespace:  * dapr-operator: manages all components for state store, pub/sub,    configuration, etc  * dapr-sidecar-injector: injects dapr sidecars into deployment pods  * dapr-placement: required with actors only.  * dapr-sentry: manages mTLS between services and acts as a certificate    authority.  * dapr-dashboard: a simple webapp to explore what is running within a Dapr    cluster  These Pods collectively represent the Dapr .  Injecting a sidecar    From here on, adding a Dapr sidecar to an application (this would be Dapr dataplane) is as easy as adding the following to your Kubernetes Deployments:   annotations:     dapr.io/enabled: \"true\"     dapr.io/app-id: \"nodeapp\"     dapr.io/app-port: \"3000\"   The dapr-sidecar-injector service watches for new Pods with the dapr.io/enabled annotation and injects a container with the daprd process within the pod. It also adds DAPR_HTTP_PORT and DAPR_GRPC_PORT environment variables to your container so that it can easily communicate with Dapr without hard-coding Dapr port values.  To deploy a complete application on Kubernetes I suggest this step-by-step . It has a provider and consumer services and it worked the first time for me.   TRANSPARENT VS EXPLICIT PROXY  Notice Dapr sidecar injection is less intrusive than a typical service mesh with a transparent sidecar such as Istio’s Envoy. To inject a transparent proxy, typically the Pods also get injected with an init-container that runs at the start of the Pod and re-configures the Pods networking rules so that all ingress and egress traffic or your application container goes through the sidecar. With Dapr, that is not the case. There is a sidecar injected, but your application is in control of when and how to interact with Dapr over its well-defined explicit (non-transparent) APIs. Transparent service mesh proxies operate at lower network layers typically used by operations teams, whereas Dapr provides application layer primitives needed by developers. If you are interested in this topic, is a good explanation of the differences and overlaps of Dapr with services meshes.    SUMMARY  And finally, here are some closing thoughts with what I so far liked more and what less from Dapr.  LIKED MORE   * I love the fact that Dapr is one of the few CNCF projects targeting    developers creating applications, and not only operations team who are    running these applications. We need more cloudnative tools for implementing    applications.  * I love the non-intrusive nature of Dapr where capabilities are exposed over    clear APIs and not through some black magic. I prefer transparent actions for    instrumentation, observability, and general application insight, but not for    altering application behavior.  * I loved the polyglot nature of Dapr offering its capabilities to all    programming languages and runtimes. This is what attracted me to Kubernetes    and cloudnative in the first place.  * I loved how easy it is to get started with Dapr and the many permutations of    each quickstart. There is something for everyone regardless of where you are    coming from into Dapr.  * I’m excited about WASM and remote components features coming into Dapr. These    will open new surface areas for more contributions and integrations.  LIKED LESS   * I haven’t used actors before and it feels odd to have a specific programming    model included in a generic distributed systems toolkit. Luckily you don’t    have to use it if you don’t want to.  * The documentation is organized, but too sparse into multiple short pages.    Learning a topic will require navigating a lot of pages multiple times, and    it is still hard to find what you are looking for.  Follow me at to join my journey of learning and using Dapr and shout out with any thoughts and comments."
}
{
  "title": "Quarkus Infinispan Embedded extension",
  "link": "https://quarkus.io/blog/quarkus-infinispan-embedded/",
  "author": [
    {
      "name": "Katia Aresti",
      "avatar": null
    }
  ],
  "date": "2024-12-18T00:00:00.000Z",
  "feed_title": "Quarkus",
  "content": "We are excited to announce the first release of the Quarkus Infinispan Embedded Extension! This extension is now available in the Quarkiverse Hub. It is a big step forward for developers who want to use Infinispan in embedded mode with Quarkus.   WHAT IS INFINISPAN EMBEDDED MODE?  Infinispan is a powerful, distributed in-memory data store and cache. In embedded mode, Infinispan runs within your application, in library mode, without needing a separate server. This means your app can handle data caching and storage directly in its own process, making it faster and simpler.   WHY USE THE QUARKUS INFINISPAN EMBEDDED EXTENSION?  The new extension makes it easy to use Infinispan with Quarkus requiring minimal setup and delivering fast in-memory performance to your Quarkus apps.   USE CASES FOR INFINISPAN EMBEDDED IN QUARKUS  Here are some scenarios where using Infinispan in embedded mode with Quarkus might be a great fit:  In-Memory Caching: Use Infinispan as a local cache to speed up data retrieval and reduce database load in your application.  Temporary Data Processing: Manage and process temporary or short-lived data directly within the application.  Local Data Storage for Microservices: Use Infinispan as a lightweight, in-memory store for individual microservices that don’t require centralized data persistence.  Offline Applications: When working with offline or edge applications where an external server is not available, Infinispan embedded mode ensures data is stored locally and efficiently.  Data Replication in Small Clusters: Use Infinispan to handle data replication across a few nodes without the overhead of a separate Infinispan server.   TRADE-OFFS OF USING INFINISPAN IN EMBEDDED MODE  While running Infinispan in embedded mode offers simplicity and speed, there are some trade-offs to consider. Since Infinispan runs within your application’s process, it shares the same memory and CPU resources. This can increase your application’s resource usage, especially as the data size grows. Additionally, embedded mode is best suited for single-node or small-scale deployments; for larger, distributed systems, using Infinispan in remote mode with a dedicated server may offer better scalability and separation of concerns.   INFINISPAN EMBEDDED AND KUBERNETES DEPLOYMENTS  When running applications on Kubernetes, using Infinispan in embedded mode can introduce additional challenges. For instance, scaling an embedded Infinispan setup requires scaling the entire application pod, which may not be as efficient as scaling an external Infinispan cluster independently. Kubernetes' ability to handle distributed workloads aligns better with remote Infinispan setups, where storage and application layers can scale separately for improved resource management.  For more information, check the in the official Infinispan documentation.   HOW TO GET STARTED  Getting started is very easy. Just add the dependency to your Quarkus application:  <dependency>     <groupId>io.quarkiverse.infinispan</groupId>     <artifactId>quarkus-infinispan-embedded</artifactId>     <version>1.0.1</version> </dependency>  Then you can Inject the EmbeddedCacheManager and interact with Infinispan.  @Inject private EmbeddedCacheManager cacheManager;  To enable Protobuf serialization, you define a schema like this:  @Proto public record Greeting(String name, String message) {     @ProtoSchema(includeClasses = { Greeting.class }, schemaPackageName = \"io.quarkiverse.infinispan\")     public interface GreetingSchema extends GeneratedSchema {     } }  Using the EmbeddedCacheManager you will be able to create caches on the fly.  Configuration config = new ConfigurationBuilder()                 .encoding().mediaType(MediaType.APPLICATION_PROTOSTREAM)                 .clustering().cacheMode(CacheMode.DIST_ASYNC).build();  // Create a cache Cache<String, Greeting> cache = cacheManager.administration() .withFlags(CacheContainerAdmin.AdminFlag.VOLATILE) .getOrCreateCache(\"mycache\", config);  // Put a value in the cache cache.put(id, greeting);  // Read a value from the cache cache.get(id);   NATIVE SUPPORT AND FUTURE FEATURES  The Quarkus Infinispan Embedded Extension supports native mode, but some advanced features may be limited. We encourage developers to test it, share feedback, and help us enhance its capabilities.   WHERE TO LEARN MORE  For detailed documentation and examples, check out the project in the Quarkiverse Hub:   COME JOIN US  We welcome your feedback and contributions to improve the extension. Feel free to open issues, suggest features, or contribute code on the project’s GitHub repository. Thank you for being part of the Quarkus community. We hope you enjoy the new Infinispan Embedded Extension! If you are a Quarkus user or just curious, don’t be shy and join our welcoming community:   * provide feedback on ;   * craft some code and ;   * ask your questions on .   * discuss with us on , or on the ;"
}
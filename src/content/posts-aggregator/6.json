{
  "title": "Integrate Red Hat Process Automation Manager with Springboot",
  "link": "https://blog.kie.org/2022/12/integrate-red-hat-process-automation-manager-with-springboot.html",
  "author": [
    {
      "name": "Archana Krishnan",
      "avatar": null
    }
  ],
  "date": "2022-12-08T23:16:25.000Z",
  "feed_title": "KIE Community",
  "content": "We worked on a request to migrate RHPAM/EAP applications to RHPAM/Springboot. The following steps were adopted to help the client move into RHPAM/Springboot containers.   ENVIRONMENT:   * Red Hat Process Automation Manager (7.12.1) connected to PostgreSQL  * Red Hat AMQ 7.10  * Red Hat Openshift Container Platform 4.10   DATABASE CONFIGURATION:  There are differences in the sequence configured for RHPAM/EAP application and RHPAM/Springboot applications. Please run the below script to update sequence:  alter sequence BAM_TASK_ID_SEQ increment by 50; alter sequence CASE_ID_INFO_ID_SEQ increment by 50; alter sequence CONTEXT_MAPPING_INFO_ID_SEQ increment by 50; alter sequence CORRELATION_KEY_ID_SEQ increment by 50; alter sequence CORRELATION_PROP_ID_SEQ increment by 50; alter sequence ERROR_INFO_ID_SEQ increment by 50; alter sequence PROCESS_INSTANCE_INFO_ID_SEQ increment by 50; alter sequence REQUEST_INFO_ID_SEQ increment by 50; alter sequence SESSIONINFO_ID_SEQ increment by 50; alter sequence TASK_DEF_ID_SEQ increment by 50; alter sequence TASK_EVENT_ID_SEQ increment by 50; alter sequence WORKITEMINFO_ID_SEQ increment by 50;  Update application.properties with the following properties to connect to PostgreSQL:  spring.datasource.username=jbpm spring.datasource.password=jbpm spring.datasource.url=jdbc:postgresql://localhost:5432/jbpm spring.datasource.driver-class-name=org.postgresql.Driver spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect spring.jpa.hibernate.ddl-auto=validate spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl  PersistenceException is expected if the sequence is not updated and RHPAM/Springboot application tries to connect to the database:  org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/jbpm/springboot/autoconfigure/JBPMAutoConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: org.jbpm.domain] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.MappingException: Could not instantiate id generator [entity-name=org.jbpm.services.task.impl.model.TaskDefImpl]  Caused by: org.hibernate.MappingException: The increment size of the [TASK_DEF_ID_SEQ] sequence is set to [50] in the entity mapping while the associated database sequence increment size is [1].   AMQ CONFIGURATION:  Update the application.properties with the following parameters to connect to AMQ:  amqphub.amqp10jms.remoteUrl=amqp://localhost:5672 amqphub.amqp10jms.username=admin amqphub.amqp10jms.password=admin jms.queue.destination=request-queue   KIE SERVER CONFIGURATION:  Update application.properties with the following properties:  server.address=0.0.0.0 server.port=8090  cxf.path=/rest  #kie server config kieserver.serverId=sp-sb-kie-server kieserver.serverName=sp-sb-kie-server kieserver.location=http://localhost:8090/rest/server kieserver.classPathContainer=true  #kie server capabilities kieserver.drools.enabled=true kieserver.dmn.enabled=true kieserver.jbpm.enabled=true kieserver.jbpmui.enabled=true kieserver.casemgmt.enabled=true #kieserver.prometheus.enabled=true kieserver.swagger.enabled=true  kieserver.deployments[<n>].containerId=<container> kieserver.deployments[<n>].alias=<alias> kieserver.deployments[<n>].artifactId=<artifact> kieserver.deployments[<n>].groupId=<group> kieserver.deployments[<n>].version=<version>  #jbpm configuration jbpm.executor.enabled=true jbpm.executor.retries=5 jbpm.executor.interval=3 jbpm.executor.threadPoolSize=10 jbpm.executor.timeUnit=SECONDS  #transaction manager configuration spring.jta.narayana.transaction-manager-id=1  #banner spring.banner.location=classpath:banner.txt  narayana.transaction-manager-id=1 narayana.default-timeout=120 narayana.dbcp.enabled=true  #logging logging.level.org.kie: INFO logging.level.org.jbpm: ERROR    QUARTZ TIMER CONFIGURATION:  DDL script to include DB configuration for quartz timer:  CREATE TABLE qrtz_job_details   (     SCHED_NAME VARCHAR(120) NOT NULL,     JOB_NAME  VARCHAR(200) NOT NULL,     JOB_GROUP VARCHAR(200) NOT NULL,     DESCRIPTION VARCHAR(250) NULL,     JOB_CLASS_NAME   VARCHAR(250) NOT NULL,     IS_DURABLE BOOL NOT NULL,     IS_NONCONCURRENT BOOL NOT NULL,     IS_UPDATE_DATA BOOL NOT NULL,     REQUESTS_RECOVERY BOOL NOT NULL,     JOB_DATA BYTEA NULL,     PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP) );  CREATE TABLE qrtz_triggers   (     SCHED_NAME VARCHAR(120) NOT NULL,     TRIGGER_NAME VARCHAR(200) NOT NULL,     TRIGGER_GROUP VARCHAR(200) NOT NULL,     JOB_NAME  VARCHAR(200) NOT NULL,     JOB_GROUP VARCHAR(200) NOT NULL,     DESCRIPTION VARCHAR(250) NULL,     NEXT_FIRE_TIME BIGINT NULL,     PREV_FIRE_TIME BIGINT NULL,     PRIORITY INTEGER NULL,     TRIGGER_STATE VARCHAR(16) NOT NULL,     TRIGGER_TYPE VARCHAR(8) NOT NULL,     START_TIME BIGINT NOT NULL,     END_TIME BIGINT NULL,     CALENDAR_NAME VARCHAR(200) NULL,     MISFIRE_INSTR SMALLINT NULL,     JOB_DATA BYTEA NULL,     PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),     FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)     REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP) );  CREATE TABLE qrtz_simple_triggers   (     SCHED_NAME VARCHAR(120) NOT NULL,     TRIGGER_NAME VARCHAR(200) NOT NULL,     TRIGGER_GROUP VARCHAR(200) NOT NULL,     REPEAT_COUNT BIGINT NOT NULL,     REPEAT_INTERVAL BIGINT NOT NULL,     TIMES_TRIGGERED BIGINT NOT NULL,     PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),     FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)     REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) );  CREATE TABLE qrtz_cron_triggers   (     SCHED_NAME VARCHAR(120) NOT NULL,     TRIGGER_NAME VARCHAR(200) NOT NULL,     TRIGGER_GROUP VARCHAR(200) NOT NULL,     CRON_EXPRESSION VARCHAR(120) NOT NULL,     TIME_ZONE_ID VARCHAR(80),     PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),     FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)     REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) );  CREATE TABLE qrtz_simprop_triggers   (     SCHED_NAME VARCHAR(120) NOT NULL,     TRIGGER_NAME VARCHAR(200) NOT NULL,     TRIGGER_GROUP VARCHAR(200) NOT NULL,     STR_PROP_1 VARCHAR(512) NULL,     STR_PROP_2 VARCHAR(512) NULL,     STR_PROP_3 VARCHAR(512) NULL,     INT_PROP_1 INT NULL,     INT_PROP_2 INT NULL,     LONG_PROP_1 BIGINT NULL,     LONG_PROP_2 BIGINT NULL,     DEC_PROP_1 NUMERIC(13,4) NULL,     DEC_PROP_2 NUMERIC(13,4) NULL,     BOOL_PROP_1 BOOL NULL,     BOOL_PROP_2 BOOL NULL,     PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),     FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)     REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) );  CREATE TABLE qrtz_blob_triggers   (     SCHED_NAME VARCHAR(120) NOT NULL,     TRIGGER_NAME VARCHAR(200) NOT NULL,     TRIGGER_GROUP VARCHAR(200) NOT NULL,     BLOB_DATA BYTEA NULL,     PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),     FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)         REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) );  CREATE TABLE qrtz_calendars   (     SCHED_NAME VARCHAR(120) NOT NULL,     CALENDAR_NAME  VARCHAR(200) NOT NULL,     CALENDAR BYTEA NOT NULL,     PRIMARY KEY (SCHED_NAME,CALENDAR_NAME) );  CREATE TABLE qrtz_paused_trigger_grps   (     SCHED_NAME VARCHAR(120) NOT NULL,     TRIGGER_GROUP  VARCHAR(200) NOT NULL,     PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP) );  CREATE TABLE qrtz_fired_triggers   (     SCHED_NAME VARCHAR(120) NOT NULL,     ENTRY_ID VARCHAR(95) NOT NULL,     TRIGGER_NAME VARCHAR(200) NOT NULL,     TRIGGER_GROUP VARCHAR(200) NOT NULL,     INSTANCE_NAME VARCHAR(200) NOT NULL,     FIRED_TIME BIGINT NOT NULL,     SCHED_TIME BIGINT NOT NULL,     PRIORITY INTEGER NOT NULL,     STATE VARCHAR(16) NOT NULL,     JOB_NAME VARCHAR(200) NULL,     JOB_GROUP VARCHAR(200) NULL,     IS_NONCONCURRENT BOOL NULL,     REQUESTS_RECOVERY BOOL NULL,     PRIMARY KEY (SCHED_NAME,ENTRY_ID) );  CREATE TABLE qrtz_scheduler_state   (     SCHED_NAME VARCHAR(120) NOT NULL,     INSTANCE_NAME VARCHAR(200) NOT NULL,     LAST_CHECKIN_TIME BIGINT NOT NULL,     CHECKIN_INTERVAL BIGINT NOT NULL,     PRIMARY KEY (SCHED_NAME,INSTANCE_NAME) );  CREATE TABLE qrtz_locks   (     SCHED_NAME VARCHAR(120) NOT NULL,     LOCK_NAME  VARCHAR(40) NOT NULL,     PRIMARY KEY (SCHED_NAME,LOCK_NAME) );  create index idx_qrtz_j_req_recovery on qrtz_job_details(SCHED_NAME,REQUESTS_RECOVERY); create index idx_qrtz_j_grp on qrtz_job_details(SCHED_NAME,JOB_GROUP);  create index idx_qrtz_t_j on qrtz_triggers(SCHED_NAME,JOB_NAME,JOB_GROUP); create index idx_qrtz_t_jg on qrtz_triggers(SCHED_NAME,JOB_GROUP); create index idx_qrtz_t_c on qrtz_triggers(SCHED_NAME,CALENDAR_NAME); create index idx_qrtz_t_g on qrtz_triggers(SCHED_NAME,TRIGGER_GROUP); create index idx_qrtz_t_state on qrtz_triggers(SCHED_NAME,TRIGGER_STATE); create index idx_qrtz_t_n_state on qrtz_triggers(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE); create index idx_qrtz_t_n_g_state on qrtz_triggers(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE); create index idx_qrtz_t_next_fire_time on qrtz_triggers(SCHED_NAME,NEXT_FIRE_TIME); create index idx_qrtz_t_nft_st on qrtz_triggers(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME); create index idx_qrtz_t_nft_misfire on qrtz_triggers(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME); create index idx_qrtz_t_nft_st_misfire on qrtz_triggers(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE); create index idx_qrtz_t_nft_st_misfire_grp on qrtz_triggers(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);  create index idx_qrtz_ft_trig_inst_name on qrtz_fired_triggers(SCHED_NAME,INSTANCE_NAME); create index idx_qrtz_ft_inst_job_req_rcvry on qrtz_fired_triggers(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY); create index idx_qrtz_ft_j_g on qrtz_fired_triggers(SCHED_NAME,JOB_NAME,JOB_GROUP); create index idx_qrtz_ft_jg on qrtz_fired_triggers(SCHED_NAME,JOB_GROUP); create index idx_qrtz_ft_t_g on qrtz_fired_triggers(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP); create index idx_qrtz_ft_tg on qrtz_fired_triggers(SCHED_NAME,TRIGGER_GROUP);  Add the quartz properties file at src/main/resources/quartz.properties:  #============================================================================ # Configure Main Scheduler Properties #============================================================================ org.quartz.scheduler.instanceName = SpringBootScheduler org.quartz.scheduler.instanceId = AUTO org.quartz.scheduler.skipUpdateCheck=true org.quartz.scheduler.idleWaitTime=1000 #============================================================================ # Configure ThreadPool #============================================================================ org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool org.quartz.threadPool.threadCount = 5 org.quartz.threadPool.threadPriority = 5 #============================================================================ # Configure JobStore #============================================================================ org.quartz.jobStore.misfireThreshold = 60000 org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreCMT org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate org.quartz.jobStore.useProperties=false org.quartz.jobStore.dataSource=myDS org.quartz.jobStore.nonManagedTXDataSource=notManagedDS org.quartz.jobStore.tablePrefix=QRTZ_ org.quartz.jobStore.isClustered=true org.quartz.jobStore.clusterCheckinInterval = 5000 #============================================================================ # Configure Datasources #============================================================================ org.quartz.dataSource.myDS.connectionProvider.class=org.jbpm.springboot.quartz.SpringConnectionProvider org.quartz.dataSource.myDS.dataSourceName=quartzDataSource org.quartz.dataSource.notManagedDS.connectionProvider.class=org.jbpm.springboot.quartz.SpringConnectionProvider org.quartz.dataSource.notManagedDS.dataSourceName=quartzNotManagedDataSource  Update the application.properties:  jbpm.quartz.enabled=true jbpm.quartz.configuration=quartz.properties   STEPS TO DEPLOY THE APPLICATION TO OCP 4.10   1. Create ocp-image directory outside the business-application project with the     following structure:  ocp-image |--/root   |--/opt     |-- /spring-service   2. Copy JAR file to root/opt/spring-service. For example:  cd ../business-application cp target/business-application-1.0-SNAPSHOT.jar ../ocp-image/root/opt/spring-service/   3. Create a Dockerfile with the following content in the directory /ocp-image/  FROM registry.access.redhat.com/ubi8/openjdk-11:latest COPY root / EXPOSE 8090 WORKDIR /opt/spring-service/ RUN chown -R jboss:root /opt/spring-service/ && chmod 777 /opt/spring-service/ CMD [\"sh\",\"-c\", \"java ${JAVA_OPTIONS} -Dorg.kie.server.mode=PRODUCTION -jar /opt/spring-service/<FILENAME>.jar\"]   4. Build and deploy application to OCP 4.10  oc new-build --binary --strategy=docker --name kie-springboot oc start-build kie-springboot --from-dir=. --follow oc new-app kie-springboot oc expose service/kie-springboot --port=8090  The post appeared first on ."
}